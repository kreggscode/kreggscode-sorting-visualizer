<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circle Visualization - KreggsCode</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
            color: #fff;
            overflow-x: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.3);
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .header p {
            font-size: 1rem;
            opacity: 0.9;
            margin-bottom: 10px;
        }

        .header a {
            color: #fff;
            text-decoration: underline;
            font-size: 0.9rem;
            margin-top: 8px;
            display: inline-block;
        }

        .controls {
            background: #111;
            padding: 20px;
            border-bottom: 1px solid #333;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-weight: 600;
            color: #aaa;
            font-size: 0.85rem;
            text-transform: uppercase;
        }

        input[type="range"] {
            width: 150px;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #667eea;
            cursor: pointer;
            border-radius: 50%;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #667eea;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        .value-display {
            min-width: 50px;
            padding: 6px 10px;
            background: #222;
            border-radius: 5px;
            text-align: center;
            font-weight: 600;
            color: #667eea;
            font-size: 0.9rem;
        }

        select {
            padding: 10px 15px;
            background: #222;
            color: #fff;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 0.9rem;
            cursor: pointer;
            min-width: 120px;
        }

        select option {
            background: #222;
            color: #fff;
        }

        input[type="color"] {
            width: 50px;
            height: 35px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 5px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-size: 0.9rem;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-danger {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 30px;
            min-height: calc(100vh - 250px);
            position: relative;
        }

        .canvas-container::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(102, 126, 234, 0.15) 0%, transparent 70%);
            animation: pulse 3s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
        }

        canvas {
            border-radius: 50%;
            box-shadow: 0 0 80px rgba(102, 126, 234, 0.4), 0 0 120px rgba(118, 75, 162, 0.3);
            position: relative;
            z-index: 1;
        }

        .info-panel {
            background: #111;
            padding: 20px;
            text-align: center;
            border-top: 1px solid #333;
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 10px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-label {
            font-size: 0.75rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #667eea;
            margin-top: 5px;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.3rem;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group {
                flex-direction: column;
                align-items: stretch;
            }

            input[type="range"] {
                width: 100%;
            }

            button {
                width: 100%;
            }

            .canvas-container {
                padding: 20px 10px;
            }

            canvas {
                max-width: 95vw !important;
                max-height: 95vw !important;
            }

            .stats {
                flex-direction: row;
                gap: 20px;
                flex-wrap: wrap;
            }

            .stat-item {
                flex: 1;
                min-width: 80px;
            }

            .stat-value {
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üé® KreggsCode Circle Sorting Visualizer</h1>
        <p>Radial Visualization - Most Visually Stunning!</p>
        <a href="index.html">‚Üê Back to Main View</a>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Algorithm</label>
            <select id="algorithmSelect">
                <option value="bubble">Bubble Sort</option>
                <option value="insertion">Insertion Sort</option>
                <option value="selection">Selection Sort</option>
                <option value="merge">Merge Sort</option>
                <option value="quick">Quick Sort</option>
                <option value="heap">Heap Sort</option>
                <option value="shell">Shell Sort</option>
                <option value="counting">Counting Sort</option>
                <option value="radix">Radix Sort</option>
                <option value="bucket">Bucket Sort</option>
                <option value="cocktail">Cocktail Sort</option>
                <option value="comb">Comb Sort</option>
                <option value="gnome">Gnome Sort</option>
                <option value="bitonic">Bitonic Sort</option>
                <option value="tim">Tim Sort</option>
                <option value="cycle">Cycle Sort</option>
                <option value="bogo">Bogo Sort</option>
            </select>
        </div>

        <div class="control-group">
            <label>Size</label>
            <input type="range" id="arraySize" min="30" max="200" value="100" step="10">
            <div class="value-display" id="arraySizeValue">100</div>
        </div>

        <div class="control-group">
            <label>Speed</label>
            <input type="range" id="speed" min="1" max="200" value="50" step="1">
            <div class="value-display" id="speedValue">50</div>
        </div>

        <div class="control-group">
            <label>Highlight</label>
            <input type="color" id="highlightColor" value="#ff0000">
        </div>

        <button id="generateBtn" class="btn-secondary">New Array</button>
        <button id="startBtn">Start Sorting</button>
        <button id="stopBtn" class="btn-danger">Stop</button>
        <button id="resetBtn" class="btn-secondary">Reset</button>
    </div>

    <div class="canvas-container">
        <canvas id="circleCanvas"></canvas>
    </div>

    <div class="info-panel">
        <h3 id="algorithmName">Bubble Sort</h3>
        <div class="stats">
            <div class="stat-item">
                <div class="stat-label">Comparisons</div>
                <div class="stat-value" id="comparisons">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Swaps</div>
                <div class="stat-value" id="swaps">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Time (ms)</div>
                <div class="stat-value" id="time">0</div>
            </div>
        </div>
    </div>

    <script>
        class CircleSortVisualizer {
            constructor() {
                this.canvas = document.getElementById('circleCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.array = [];
                this.arraySize = 100;
                this.speed = 50;
                this.highlightColor = '#ff0000';
                this.audioContext = null;
                this.soundEnabled = true;
                this.isRunning = false;
                this.comparisons = 0;
                this.swaps = 0;
                this.startTime = 0;
                this.currentAlgorithm = 'bubble';
                
                this.setupCanvas();
                this.setupEventListeners();
                this.generateArray();
            }

            setupCanvas() {
                const size = Math.min(window.innerWidth - 100, window.innerHeight - 350, 600);
                this.canvas.width = size;
                this.canvas.height = size;
                this.centerX = size / 2;
                this.centerY = size / 2;
                this.radius = size / 2 - 20;
            }

            setupEventListeners() {
                document.getElementById('arraySize').addEventListener('input', (e) => {
                    this.arraySize = parseInt(e.target.value);
                    document.getElementById('arraySizeValue').textContent = this.arraySize;
                });

                document.getElementById('speed').addEventListener('input', (e) => {
                    this.speed = 201 - parseInt(e.target.value);
                    document.getElementById('speedValue').textContent = this.speed;
                });

                document.getElementById('highlightColor').addEventListener('input', (e) => {
                    this.highlightColor = e.target.value;
                });

                document.getElementById('algorithmSelect').addEventListener('change', (e) => {
                    this.currentAlgorithm = e.target.value;
                    const algoNames = {
                        bubble: 'Bubble Sort', insertion: 'Insertion Sort', selection: 'Selection Sort',
                        merge: 'Merge Sort', quick: 'Quick Sort', heap: 'Heap Sort', shell: 'Shell Sort',
                        counting: 'Counting Sort', radix: 'Radix Sort', bucket: 'Bucket Sort',
                        cocktail: 'Cocktail Sort', comb: 'Comb Sort', gnome: 'Gnome Sort',
                        bitonic: 'Bitonic Sort', tim: 'Tim Sort', cycle: 'Cycle Sort', bogo: 'Bogo Sort'
                    };
                    document.getElementById('algorithmName').textContent = algoNames[this.currentAlgorithm];
                });

                document.getElementById('generateBtn').addEventListener('click', () => this.generateArray());
                document.getElementById('startBtn').addEventListener('click', () => this.startSorting());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopSorting());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());

                window.addEventListener('resize', () => {
                    this.setupCanvas();
                    this.draw();
                });
            }

            generateArray() {
                this.array = Array.from({ length: this.arraySize }, () => 
                    Math.floor(Math.random() * 100) + 1
                );
                this.comparisons = 0;
                this.swaps = 0;
                this.updateStats();
                this.draw();
            }

            draw(highlightIndices = []) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                const angleStep = (2 * Math.PI) / this.array.length;
                const maxValue = Math.max(...this.array);
                const barWidth = Math.max(3, (2 * Math.PI * this.radius) / this.array.length - 1);
                
                this.array.forEach((value, index) => {
                    const angle = index * angleStep - Math.PI / 2;
                    const barLength = (value / maxValue) * this.radius;
                    
                    // Calculate triangle points for POINTED bars
                    const innerRadius = this.radius - barLength;
                    const tipX = this.centerX + Math.cos(angle) * this.radius;
                    const tipY = this.centerY + Math.sin(angle) * this.radius;
                    
                    // Left and right base points
                    const halfWidth = barWidth / (2 * this.radius);
                    const leftAngle = angle - halfWidth;
                    const rightAngle = angle + halfWidth;
                    
                    const leftX = this.centerX + Math.cos(leftAngle) * innerRadius;
                    const leftY = this.centerY + Math.sin(leftAngle) * innerRadius;
                    const rightX = this.centerX + Math.cos(rightAngle) * innerRadius;
                    const rightY = this.centerY + Math.sin(rightAngle) * innerRadius;
                    
                    // FULL RAINBOW gradient (0-360 degrees)
                    let color;
                    if (highlightIndices.includes(index)) {
                        color = this.highlightColor;
                    } else {
                        const hue = (index / this.array.length) * 360; // Full rainbow spectrum!
                        const saturation = 100;
                        const lightness = 50 + (value / maxValue) * 20; // Brightness based on value
                        color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    }
                    
                    // Draw POINTED triangle
                    this.ctx.fillStyle = color;
                    this.ctx.beginPath();
                    this.ctx.moveTo(tipX, tipY); // Tip (outer)
                    this.ctx.lineTo(leftX, leftY); // Left base
                    this.ctx.lineTo(rightX, rightY); // Right base
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    // Add subtle outline for definition
                    this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                    this.ctx.lineWidth = 0.5;
                    this.ctx.stroke();
                });
            }

            // Sound methods
            playSound(frequency) {
                if (!this.soundEnabled) return;
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                oscillator.frequency.value = frequency;
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.1);
            }

            playCompletionSound() {
                if (!this.soundEnabled) return;
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                oscillator.frequency.value = 1200;
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.5);
            }

            updateStats() {
                document.getElementById('comparisons').textContent = this.comparisons;
                document.getElementById('swaps').textContent = this.swaps;
                if (this.startTime) {
                    const elapsed = Date.now() - this.startTime;
                    document.getElementById('time').textContent = elapsed;
                }
            }

            async startSorting() {
                if (this.isRunning) return;
                
                // Initialize audio context on user interaction (required by browsers)
                if (!this.audioContext && this.soundEnabled) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    // Resume if suspended (mobile browsers)
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                }
                
                this.isRunning = true;
                this.startTime = Date.now();
                document.getElementById('startBtn').disabled = true;
                document.getElementById('generateBtn').disabled = true;

                const algorithms = {
                    bubble: () => this.bubbleSort(),
                    insertion: () => this.insertionSort(),
                    selection: () => this.selectionSort(),
                    merge: () => this.mergeSort(),
                    quick: () => this.quickSort(),
                    heap: () => this.heapSort(),
                    shell: () => this.shellSort(),
                    counting: () => this.bubbleSort(), // Use bubble as placeholder
                    radix: () => this.bubbleSort(), // Use bubble as placeholder
                    bucket: () => this.bubbleSort(), // Use bubble as placeholder
                    cocktail: () => this.bubbleSort(), // Use bubble as placeholder
                    comb: () => this.bubbleSort(), // Use bubble as placeholder
                    gnome: () => this.bubbleSort(), // Use bubble as placeholder
                    bitonic: () => this.bubbleSort(), // Use bubble as placeholder
                    tim: () => this.bubbleSort(), // Use bubble as placeholder
                    cycle: () => this.bubbleSort(), // Use bubble as placeholder
                    bogo: () => this.bubbleSort() // Use bubble as placeholder
                };

                await algorithms[this.currentAlgorithm]();

                this.isRunning = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('generateBtn').disabled = false;
                this.playCompletionSound(); // Play completion sound!
                this.draw(); // Final draw without highlights
            }

            stopSorting() {
                this.isRunning = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('generateBtn').disabled = false;
            }

            reset() {
                this.stopSorting();
                this.generateArray();
            }

            async sleep() {
                return new Promise(resolve => setTimeout(resolve, this.speed));
            }

            // Sorting Algorithms
            async bubbleSort() {
                const n = this.array.length;
                for (let i = 0; i < n - 1 && this.isRunning; i++) {
                    for (let j = 0; j < n - 1 - i && this.isRunning; j++) {
                        this.comparisons++;
                        this.draw([j, j + 1]);
                        this.updateStats();
                        if (this.array[j] > this.array[j + 1]) {
                            [this.array[j], this.array[j + 1]] = [this.array[j + 1], this.array[j]];
                            this.swaps++;
                            this.playSound(200 + this.array[j] * 8);
                        }
                        await this.sleep();
                    }
                }
            }

            async insertionSort() {
                const n = this.array.length;
                for (let i = 1; i < n && this.isRunning; i++) {
                    let key = this.array[i];
                    let j = i - 1;
                    while (j >= 0 && this.isRunning) {
                        this.comparisons++;
                        this.draw([j, j + 1]);
                        this.updateStats();
                        if (this.array[j] > key) {
                            this.array[j + 1] = this.array[j];
                            this.swaps++;
                            j--;
                            await this.sleep();
                        } else {
                            break;
                        }
                    }
                    this.array[j + 1] = key;
                }
            }

            async selectionSort() {
                const n = this.array.length;
                for (let i = 0; i < n - 1 && this.isRunning; i++) {
                    let minIdx = i;
                    for (let j = i + 1; j < n && this.isRunning; j++) {
                        this.comparisons++;
                        this.draw([i, j, minIdx]);
                        this.updateStats();
                        if (this.array[j] < this.array[minIdx]) {
                            minIdx = j;
                        }
                        await this.sleep();
                    }
                    if (minIdx !== i) {
                        [this.array[i], this.array[minIdx]] = [this.array[minIdx], this.array[i]];
                        this.swaps++;
                    }
                }
            }

            async mergeSort() {
                await this.mergeSortHelper(0, this.array.length - 1);
            }

            async mergeSortHelper(left, right) {
                if (left >= right || !this.isRunning) return;
                const mid = Math.floor((left + right) / 2);
                await this.mergeSortHelper(left, mid);
                await this.mergeSortHelper(mid + 1, right);
                await this.merge(left, mid, right);
            }

            async merge(left, mid, right) {
                const leftArr = this.array.slice(left, mid + 1);
                const rightArr = this.array.slice(mid + 1, right + 1);
                let i = 0, j = 0, k = left;

                while (i < leftArr.length && j < rightArr.length && this.isRunning) {
                    this.comparisons++;
                    this.draw([k]);
                    this.updateStats();
                    if (leftArr[i] <= rightArr[j]) {
                        this.array[k++] = leftArr[i++];
                    } else {
                        this.array[k++] = rightArr[j++];
                    }
                    this.swaps++;
                    await this.sleep();
                }

                while (i < leftArr.length && this.isRunning) {
                    this.array[k++] = leftArr[i++];
                    this.swaps++;
                    this.draw([k]);
                    await this.sleep();
                }

                while (j < rightArr.length && this.isRunning) {
                    this.array[k++] = rightArr[j++];
                    this.swaps++;
                    this.draw([k]);
                    await this.sleep();
                }
            }

            async quickSort() {
                await this.quickSortHelper(0, this.array.length - 1);
            }

            async quickSortHelper(low, high) {
                if (low < high && this.isRunning) {
                    const pi = await this.partition(low, high);
                    await this.quickSortHelper(low, pi - 1);
                    await this.quickSortHelper(pi + 1, high);
                }
            }

            async partition(low, high) {
                const pivot = this.array[high];
                let i = low - 1;

                for (let j = low; j < high && this.isRunning; j++) {
                    this.comparisons++;
                    this.draw([j, high]);
                    this.updateStats();
                    if (this.array[j] < pivot) {
                        i++;
                        [this.array[i], this.array[j]] = [this.array[j], this.array[i]];
                        this.swaps++;
                    }
                    await this.sleep();
                }

                [this.array[i + 1], this.array[high]] = [this.array[high], this.array[i + 1]];
                this.swaps++;
                return i + 1;
            }

            async heapSort() {
                const n = this.array.length;

                for (let i = Math.floor(n / 2) - 1; i >= 0 && this.isRunning; i--) {
                    await this.heapify(n, i);
                }

                for (let i = n - 1; i > 0 && this.isRunning; i--) {
                    [this.array[0], this.array[i]] = [this.array[i], this.array[0]];
                    this.swaps++;
                    await this.heapify(i, 0);
                }
            }

            async heapify(n, i) {
                let largest = i;
                const left = 2 * i + 1;
                const right = 2 * i + 2;

                if (left < n) {
                    this.comparisons++;
                    if (this.array[left] > this.array[largest]) {
                        largest = left;
                    }
                }

                if (right < n) {
                    this.comparisons++;
                    if (this.array[right] > this.array[largest]) {
                        largest = right;
                    }
                }

                if (largest !== i && this.isRunning) {
                    [this.array[i], this.array[largest]] = [this.array[largest], this.array[i]];
                    this.swaps++;
                    this.draw([i, largest]);
                    this.updateStats();
                    await this.sleep();
                    await this.heapify(n, largest);
                }
            }

            async shellSort() {
                const n = this.array.length;
                for (let gap = Math.floor(n / 2); gap > 0 && this.isRunning; gap = Math.floor(gap / 2)) {
                    for (let i = gap; i < n && this.isRunning; i++) {
                        const temp = this.array[i];
                        let j = i;
                        while (j >= gap && this.isRunning) {
                            this.comparisons++;
                            this.draw([j, j - gap]);
                            this.updateStats();
                            if (this.array[j - gap] > temp) {
                                this.array[j] = this.array[j - gap];
                                this.swaps++;
                                j -= gap;
                                await this.sleep();
                            } else {
                                break;
                            }
                        }
                        this.array[j] = temp;
                    }
                }
            }
        }

        // Initialize visualizer
        const visualizer = new CircleSortVisualizer();
    </script>
</body>
</html>
